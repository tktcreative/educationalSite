<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dispersion through a Prism - Interactive Science Lab</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Google Fonts: Inter -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700;800&display=swap" rel="stylesheet">
    
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f8fafc; /* A very light gray */
        }
    </style>
</head>
<body class="py-12 px-4 md:px-8">

    <!-- Main container -->
    <div class="max-w-7xl mx-auto">

        <!-- Header -->
        <header class="text-center mb-12">
            <h1 class="text-4xl md:text-5xl font-extrabold text-gray-800 tracking-tight">
                Dispersion through a Prism
            </h1>
            <p class="text-lg text-gray-600 mt-3 max-w-3xl mx-auto">
                Pass white light through a glass prism and observe the beautiful spectrum of seven colors.
            </p>
        </header>

        <!-- Simulation Layout -->
        <div class="grid grid-cols-1 lg:grid-cols-3 gap-8">

            <!-- Left Panel: Information & Controls -->
            <div class="lg:col-span-1 bg-white p-8 rounded-xl shadow-lg border border-gray-200">
                <h2 class="text-2xl font-bold text-gray-800 mb-4">What is Dispersion?</h2>
                <p class="text-gray-600 mb-4">
                   Dispersion of light is the phenomenon of splitting a beam of white light into its seven constituent colors when passed through a transparent medium like a glass prism.
                </p>
                <p class="text-gray-600 mb-6">
                   This happens because different colors of light travel at slightly different speeds inside the prism, causing them to bend (refract) at slightly different angles. Violet light bends the most, and red light bends the least.
                </p>
                
                <h3 class="text-xl font-semibold text-gray-800 mb-3">The Spectrum (VIBGYOR):</h3>
                 <div class="flex flex-col space-y-1">
                    <div class="h-4 w-full rounded" style="background-color: violet;"></div>
                    <div class="h-4 w-full rounded" style="background-color: indigo;"></div>
                    <div class="h-4 w-full rounded" style="background-color: blue;"></div>
                    <div class="h-4 w-full rounded" style="background-color: green;"></div>
                    <div class="h-4 w-full rounded" style="background-color: yellow;"></div>
                    <div class="h-4 w-full rounded" style="background-color: orange;"></div>
                    <div class="h-4 w-full rounded" style="background-color: red;"></div>
                 </div>
                 <div class="text-center mt-8">
                    <button id="start-btn" class="w-full bg-green-600 text-white font-semibold py-3 px-4 rounded-lg hover:bg-green-700 transition-colors">Start Animation</button>
                    <button id="reset-btn" class="w-full mt-4 bg-gray-600 text-white font-semibold py-3 px-4 rounded-lg hover:bg-gray-700 transition-colors">Reset</button>
                </div>
            </div>

            <!-- Right Panel: Interactive Simulation -->
            <div class="lg:col-span-2 bg-white p-8 rounded-xl shadow-lg border border-gray-200">
                <div class="w-full h-[60vh] relative">
                    <canvas id="simulation-canvas" class="w-full h-full bg-gray-800 rounded-lg border"></canvas>
                </div>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('simulation-canvas');
        const ctx = canvas.getContext('2d');
        const startBtn = document.getElementById('start-btn');
        const resetBtn = document.getElementById('reset-btn');

        let animationFrameId;
        let animationProgress = 0; // 0 to 1
        let stage = 'initial'; // initial, animating, finished

        const spectrum = [
            { color: 'red', angle: 20 },
            { color: 'orange', angle: 22 },
            { color: 'yellow', angle: 24 },
            { color: 'green', angle: 26 },
            { color: 'blue', angle: 28 },
            { color: 'indigo', angle: 30 },
            { color: 'violet', angle: 32 }
        ];

        function resizeCanvas() {
            const rect = canvas.parentElement.getBoundingClientRect();
            const dpr = window.devicePixelRatio || 1;
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            ctx.scale(dpr, dpr);
            canvas.style.width = `${rect.width}px`;
            canvas.style.height = `${rect.height}px`;
            draw();
        }

        function drawPrism() {
            const w = canvas.width / (window.devicePixelRatio || 1);
            const h = canvas.height / (window.devicePixelRatio || 1);
            const prism = {
                p1: { x: w * 0.4, y: h * 0.8 },
                p2: { x: w * 0.6, y: h * 0.8 },
                p3: { x: w * 0.5, y: h * 0.4 }
            };
            ctx.beginPath();
            ctx.moveTo(prism.p1.x, prism.p1.y);
            ctx.lineTo(prism.p2.x, prism.p2.y);
            ctx.lineTo(prism.p3.x, prism.p3.y);
            ctx.closePath();
            ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
            ctx.fill();
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 2;
            ctx.stroke();
            return prism;
        }

        function draw() {
            const w = canvas.width / (window.devicePixelRatio || 1);
            const h = canvas.height / (window.devicePixelRatio || 1);
            ctx.clearRect(0, 0, w, h);

            const prism = drawPrism();

            if (stage === 'initial') {
                requestAnimationFrame(draw);
                return;
            }

            // --- Ray Tracing ---
            const incidentStart = { x: 0, y: h * 0.6 };
            const incidentEnd = { x: w * 0.45, y: h * 0.6 };

            // 1. Incident Ray
            const currentIncidentEnd = {
                x: incidentStart.x + (incidentEnd.x - incidentStart.x) * Math.min(1, animationProgress * 3),
                y: incidentStart.y
            };
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(incidentStart.x, incidentStart.y);
            ctx.lineTo(currentIncidentEnd.x, currentIncidentEnd.y);
            ctx.stroke();

            if (animationProgress > 0.33) {
                // 2. Ray inside prism
                const refractedStart = incidentEnd;
                const refractedEnd = { x: w * 0.525, y: h * 0.55 };
                const currentRefractedEnd = {
                    x: refractedStart.x + (refractedEnd.x - refractedStart.x) * Math.min(1, (animationProgress - 0.33) * 3),
                    y: refractedStart.y + (refractedEnd.y - refractedStart.y) * Math.min(1, (animationProgress - 0.33) * 3)
                };
                ctx.beginPath();
                ctx.moveTo(refractedStart.x, refractedStart.y);
                ctx.lineTo(currentRefractedEnd.x, currentRefractedEnd.y);
                ctx.stroke();

                if (animationProgress > 0.66) {
                    // 3. Dispersed Rays
                    spectrum.forEach(light => {
                        // CORRECTED ANGLE CALCULATION
                        const angleRad = light.angle * (Math.PI / 180);
                        const finalX = refractedEnd.x + Math.cos(angleRad) * w;
                        const finalY = refractedEnd.y + Math.sin(angleRad) * w;
                        
                        const currentFinal = {
                           x: refractedEnd.x + (finalX - refractedEnd.x) * Math.min(1, (animationProgress - 0.66) * 3),
                           y: refractedEnd.y + (finalY - refractedEnd.y) * Math.min(1, (animationProgress - 0.66) * 3)
                        };

                        ctx.strokeStyle = light.color;
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(refractedEnd.x, refractedEnd.y);
                        ctx.lineTo(currentFinal.x, currentFinal.y);
                        ctx.stroke();
                    });
                }
            }

            if (stage === 'animating') {
                animationProgress += 0.005;
                if (animationProgress > 1) {
                    animationProgress = 1;
                    stage = 'finished';
                }
            }
            
            requestAnimationFrame(draw);
        }
        
        function startAnimation() {
            if (stage === 'initial' || stage === 'finished') {
                animationProgress = 0;
                stage = 'animating';
            }
        }

        function resetAnimation() {
            animationProgress = 0;
            stage = 'initial';
        }

        startBtn.addEventListener('click', startAnimation);
        resetBtn.addEventListener('click', resetAnimation);
        window.addEventListener('resize', resizeCanvas);

        // Initial setup
        resizeCanvas();

    </script>
</body>
</html>
